<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <meta http-equiv="imagetoolbar" content="no" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <link rel="stylesheet" href="../../css/common.css" type="text/css" />
  <link type="text/css" rel="stylesheet" href="../../css/styles/shCoreDefault.css"/>
  <script type="text/javascript" src="../../css/scripts/shCore.js"></script>
  <script type="text/javascript" src="../../css/scripts/shBrushBash.js"></script>
  <script type="text/javascript" src="../../css/scripts/shBrushCpp.js"></script>
  <script type="text/javascript" src="../../css/scripts/shBrushPlain.js"></script>
  <script type="text/javascript">SyntaxHighlighter.all();</script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ["\\[","\\]"]],
      processEscapes: true,
      skipTags: ["script","noscript","style","textarea","pre"]
    },
    TeX: {
      Macros: {
        bm: ['{\\boldsymbol{#1}}', 1],
      }
    },
    "HTML-CSS": { matchFontHeight: false }
  });
  </script>
  <!-- MathJax end -->
  <!-- google analityics -->
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-35918686-1']);
    _gaq.push(['_trackPageview']);
    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <!-- google analityics end -->
  <title>最小二乗法の実装</title>
</head>
<body>
<div id="top">

<div id="contents">
<h2>最小二乗法の実装 (<a href="../../dev_tips.html">全体の目次に戻る</a>)</h2>
<a href="what_is_LS.html">節のはじめ</a>に説明したように最小二乗法の解は$\bm{\beta}^* = (\bm{X}^\top \bm{X})^{-1} \bm{X}^\top \bm{y}$と表すことができます．
では実際にEigen C++ライブラリを用いて$\bm{\beta}^*$を求めていきます．

<h3 id="LU_CHOL">直接法</h3>
最小二乗法の解$\bm{\beta}^* = (\bm{X}^\top \bm{X})^{-1} \bm{X}^\top \bm{y}$は
\[
\begin{align*}
 (\bm{X}^\top \bm{X}) \bm{\beta} &= \bm{X}^\top \bm{y} \\
 &\downarrow \\
 \bm{A} \bm{\beta} &= \bm{b}
\end{align*}
\]
として連立一次方程式の解として求めることができます（勿論、$(\bm{X}^\top \bm{X})$の逆行列を計算して$\bm{\beta}^* = (\bm{X}^\top \bm{X})^{-1} \bm{X}^\top \bm{y}$を求めることもできますが、逆行列の計算コストや数値計算誤差が増大してしまいます）．
これをガウスの消去法やコレスキー分解などを用いて解く方法は直接法と呼ばれます．
以下、ピボット選択付きLU分解とコレスキー分解を用いた実装を示します．
<pre class="brush: cpp;">
  // LU分解（ランク落ちにも対応）
  VectorXd beta = (X.transpose() * X).fullPivLu().solve(X.transpose() * y);

  // コレスキー分解
  VectorXd beta = (X.transpose() * X).ldlt().solve(X.transpose() * y);
</pre>
Eigen には様々な連立一次方程式のソルバーが実装されており、それぞれのソルバーの特性は
<a href="http://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html">こちら</a>で説明されています．

<br/>
実際に最小二乗法を用いて$x + sin(x)$という関数を近似する例を以下に示します．
<pre class="brush: cpp;">
  int n = 30;

  // データの作成
  VectorXd x0 = VectorXd::Ones(n); // バイアス項
  VectorXd x1 = VectorXd::LinSpaced(n, 0, 5);
  MatrixXd X(n, 2);
  X << x0, x1;
  VectorXd y = x1.array() + x1.array().sin();

  // Cholesky分解
  VectorXd beta = (X.transpose() * X).ldlt().solve(X.transpose() * y);

  // 出力
  VectorXd f = X * beta;
</pre>
全体のプログラムは<a href="LU.zip">こちら</a>から入手することができます．ただし、図の出力のために導入で説明した Gnuplot interface を利用しています．
プログラムの出力結果は以下となり、赤線が$x+sin(x)$を示し、緑線が$f(\bm{X}; \bm{\beta}) = \bm{X} \bm{\beta}$を示しています．
<br/>
<img src="LU_example.png"></img>

<!----------------->

<h3 id="ITERATIVE">反復法</h3>
<a href="what_is_LS.html">節のはじめ</a>に説明したように最小二乗法では
\[\bm{\beta}^* := \arg \min_{\beta \in \mathbb{R}^d} \|\bm{X}\bm{\beta} - \bm{y}\|^2\]
を満たすパラメータ$\bm{\beta}^*$を求めます．
この$\bm{\beta}^*$は以下の図に示すように
ランダムに設定した初期値(initial point)から出発して、谷底に向かって探索することで求められます．
<br/><img src="LS_error2.png"></img><br/>

このように谷底に向かって探索することが出来る最も単純な方法の一つとして最急降下法(steepest descent method)があげられます．
最急降下法では傾斜を下るように勾配の逆方向にパラメータを更新していきます．
具体的には
\[
 \bm{\beta}^*_{t+1} \leftarrow \bm{\beta}^*_t - \eta_t \frac{\partial J(\bm{\beta}_t)}{\partial \bm{\beta}_t},
 \quad J(\bm{\beta}_t) := \|\bm{X}\bm{\beta}_t - \bm{y}\|^2
\]
により反復的に更新していきます．ここで、$\eta_t \in \mathbb{R}$ は探索幅(step size)と呼ばれ、勾配の逆方向にどのくらい進むかの歩幅を表します．

さて、勾配$\frac{\partial J(\bm{\beta}_t)}{\partial \bm{\beta}_t}$は具体的に
\[
 \frac{\partial J(\bm{\beta}_t)}{\partial \bm{\beta}_t} := 2\bm{X}^\top(\bm{X}\bm{\beta}_t - \bm{y})
\]
と求めることができます．探索幅$\eta_t$はユーザーが事前に設定しておくことも考えられますが、
最急降下法では直線探索(line search)により適用的に求めるのが普通です．
直線探索は非常に奥が深いですが、ここでは簡単に概要をまとめます．

<ul>
<li>厳密な直線探索(exact line search)</li>
<li>厳密でない直線探索</li>
</ul>
（工事中）


 </div><!-- /#contents-->

 <div id="pageTop">
   <a href="#top">このページのトップへ戻る</a>
 </div><!-- /#pageTop-->
</div><!-- /#top-->
</body>
</html>
